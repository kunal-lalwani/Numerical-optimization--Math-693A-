function [X,min] = linesearch(X)
clc;
close all;
syms x1 x2 

T = (100.*((x2-(x1.^2)).^2))+((1-x1).^2);

f = @(x) (100.*((x(2)-(x(1).^2)).^2))+((1-x(1)).^2);
gradF = @(x) [(100.*((4.*(x(1).^3))-(4.*x(1).*x(2))))+((2.*x(1))-2) ,...
            (100.*((2.*x(2))-(2.*(x(1).^2))))];

phi = @(X,P,alpha) f(X+(alpha.*P)); %Evaluate Phi.
phiDash = @(X,P,alpha) P*gradF(X+(alpha.*P))';  %Evaluate Phi'.


searchDirectionSD = @(x) -x/norm(x);
hessF = @(x) [(100*((12*(x(1)^2))-(4*x(2)))+2) , (100*(-4*x(1))) ; ...
                (100*(-4*x(1))) , 200];
funcfindnewt = @(x) (- gradF(x) * pinv(hessF(x)));

alpha = [];
storeAlpha = zeros(1,359);
X = [1.2 1.2];      % intitial value
k = 0;              % Counter for number of iterations
pk = searchDirectionSD(gradF(X));      % claculate the steepest direction
%psd = funcfindnewt(X);             % Calculate the newton direction
Z = [];     % Array for recording alpha values
points = [X];
alpha_star = 0;
while (norm(gradF(X)) > 10^-6)   % Loop until the gradient is 
                                    % nearly equal to Zero
    initialAlpha = 1;
    X1 = X + (initialAlpha.* pk);
    alpha(1) = 0;
   % Initial alpha for Steepest Direction
    alpha(2) = (pk * gradF(X)')/(searchDirectionSD(gradF(X1)) * gradF(X1)');
   % Initial alpha for Newton
%    alpha(2)=1;     
    alphaMax = 1;
    c1 = 10^-4; 
    c2 = 0.9;
    i =2;
    while (true)
        f_eval = phi(X,pk,alpha(i));
        % Armijo's condition check
        if or((f_eval>(phi(X,pk,0)+(c1.*alpha(i).*phiDash(X,pk,0)))),and(i>2,(f_eval>=phi(X,pk,alpha(i-1))))) 
            %Taking a larger step
            alpha_star = czoom(X,pk,alpha(i-1),alpha(i)); 
            break;
        end
        grad_eval = phiDash(X,pk,alpha(i));
        
        %Curvature Wolfe condition check
        if norm(grad_eval)<= (-c2.*phiDash(X,pk,0)) 
            alpha_star = alpha(i);
            break;
        end
        
        %Check if Going uphill direction
        if phiDash(X,pk,alpha(i))>=0     
            alpha_star = czoom(X,pk,alpha(i),alpha(i-1));
            break;
        end
        alpha(i+1)= (alphaMax-alpha(i))/2;
        i = i+1;
    end
    storeAlpha(k+1) = alpha_star;
    X = X + (alpha_star .* pk);     % update the initial value 
                                   % to point to new direction
    pk = searchDirectionSD(gradF(X));      % Calculate the NEW 
                                        % Steepest descent direction    
    %psd = funcfindnewt(X);     % Calculate the NEW newton direction
    k = k + 1;
     
    points = [points;X];
    fprintf('Iteration number : %d\n',k);
    fprintf('-----------------------\n');
    fprintf('Value of the variables : [%f %f]\n',X');
    fprintf('Value of the function : %f\n',f(X));
    fprintf('Value of the gradient : [%f %f]\n', gradF(X)');
    fprintf('Value of Alpha : %f\n\n\n',alpha_star);
    
    
    
end

    figure
    loglog(storeAlpha,'b-o')
    hold on
    grid on;
    str = 'Step length \alpha';
    text('Interpreter','latex')
    xlabel('Number of Iterations');
    ylabel(str);
    title('Step length Values at each iterations');
    
    figure
points = [points;X];          % Ploting contours and descent path.
[x y] = meshgrid(-1.3:0.05:1.5 , -1.3:0.05:1.5);
z = (100.*((y-(x.^2)).^2))+((1-x).^2);
contour(x,y,z,50);
hold on;
plot(points(:,1),points(:,2),'r-');
plot(points(end),'bx','LineWidth',1.5,'MarkerSize',10);
hold off;
legend('Model','NW-Dir [1.2 1.2]','Stat. pt','Newton Direction',...
       'Location','NorthEastOutside')
title(['f(x,y) = ' char(T)]);
min = f(X); 
    
end       
    